'''
Description: compute scattering lookup tables, with the IITM levelA database
generated by IITM wrapper
Author: Hejun Xie
Date: 2020-09-18 10:16:55
LastEditors: Hejun Xie
LastEditTime: 2020-09-19 14:38:55
'''


# Global imports
import os
import numpy as np
import xarray as xr
import multiprocessing as mp
from scipy import stats

# Local imports
from pyCRO.constants import global_constants as constants
from pyCRO.hydrometeors import create_hydrometeor

# define constants
BASE_FOLDER = '/mnt/e/PYCRO/'
FOLDER_LUT = BASE_FOLDER

# Specify if one-moment and/or two-moments lookup table should be computed, currently only
# one moment scheme implemented
GENERATE_1MOM = True
GENERATE_2MOM = False

# Whether to regenerate  all lookup tables, even if already present
FORCE_REGENERATION_SCATTER_TABLES = True

# The frequencies in GHz for which the lookup tables will be computed
FREQUENCIES=[9.41]

HYDROM_TYPES=['S'] # Snow, graupel, hail, rain and ice, currently only snow implemented

# the key in levelA and levelB dictionaries
real_variables      = [ 'p11_bw', 'p12_bw', 'p13_bw', 'p14_bw',
                        'p21_bw', 'p22_bw', 'p23_bw', 'p24_bw',
                        'p31_bw', 'p32_bw', 'p33_bw', 'p34_bw',
                        'p41_bw', 'p42_bw', 'p43_bw', 'p44_bw']
complex_variables   = [ 's11_fw', 's12_fw', 's21_fw', 's22_fw']

def _integrate_over_pdf(hydrom, frequency, elevation, list_D, T, ds_in):
    '''
        Computes all scattering properties for a given set of parameters and
        for a given hydrometeor, according its probability distribution function of
        orientation (orientation Euler angle beta and aspect ratio).
        This is to be used for all hydrometeors except melting snow and
        melting graupel (currently only snow implemented)
        Args:
            hydrom: a Hydrometeor Class instance (see hydrometeors.py)
            freqency: the frequency in GHz
            elevation: incident elevation angle in degrees
            list_D: list of diameters in mm for which to compute the scattering
                properties
            T: the temperature in K
            ds_in: the dataset piece sliced from levelA database ()
            
        Returns:
            ds_out: the dataset piece to be filled into levelB database ()
    '''

    return data_out


def sz_lut(hydrom_type, frequency, levela_name_lut, levelb_name_lut):
    """
        Computes and saves a scattering lookup table (level B database) for a given
        hydrometeor type (non melting) and various frequencies from level A database.
        Args:
            hydrom_type: the hydrometeor type, currently only snow is implemented.
            frequency: list of frequencies for which to obtain the
                lookup tables, in GHz.
            levela_name_lut: the filename of level A database (Input).
            levelb_name_lut: the filename of level B database (Output).
        Returns:
            No output but saves a lookup table (levelb_name_lut).
    """

    scheme = '1mom'
    
    hydrom = create_hydrometeor(hydrom_type,'1mom')	
    
    # list_D = np.linspace(hydrom.d_min,hydrom.d_max,NUM_DIAMETERS).astype('float32')

    with xr.open_dataset(levela_name_lut, engine="h5netcdf") as levela_lut:
        # Dimensions that formulate the SZ_matices
        list_elevations = levela_lut.coords["elevation"].to_numpy()
        list_temperatures = levela_lut.coords['temperature'].to_numpy()
        list_D = levela_lut.coords["Dmax"].to_numpy()
        # Note: the list_D should meet the hydrometeor list_D for fitted IITM database

        # Dimensions that should be integrated over probability distribution 
        # in levelA to levelB transformation
        list_asp = levela_lut.coords['aspect_ratio'].to_numpy()
        list_beta = levela_lut.coords['beta'].to_numpy()

        # start formulating the levelB database
        dims = ['temperature', 'Dmax', 'elevation']
        coords = {'temperature': list_temperature,
        'Dmax': list_D, 'elevation': list_elevations}
        size = tuple([len(coords[dim]) for dim in dims])
        datadic = {}
        for real_variable in real_variables:
            datadic[real_variable] = (dims, np.empty(size, dtype='float32'))
        for complex_variable in complex_variables:
            datadic[complex_variable] = (dims, np.empty(size, dtype='complex64'))
        
        levelb_lut = Dataset(datadic, coords)

        '''
        Place to hold the integration over probability distribution
        '''
        pool = mp.Pool(processes=mp.cpu_count(), maxtasksperchild=1)
        for ie, e in enumerate(list_elevations):
            for it, t in enumerate(list_temperatures):
                ds_piece = levela_lut.sel(temperature=t, elevation=e)
                args = (hydrom, frequency, e, list_D, t, ds_piece)
                ds_out = pool.apply_async(_integrate_over_pdf, args)
        
                # plug the piece of output dataset into array
                for var in ds_out.data_vars.keys():
                    levelb_lut[var].sel(temperature=t, elevation=e) = ds_out[var]

        levelb_lut.to_netcdf(levelb_name_lut, engine="h5netcdf")
        
        del levelb_lut

if __name__ == "__main__":
    '''
       Create all lookup tables for the specified hydrometeor types and
        microphysical schemes (currently only 1mom scheme implemented...)
    '''

    scheme = '1mom'
    
    for frequency in FREQUENCIES:
        for hydrom_type in HYDROM_TYPES:
            
            # The name of the lookup table is lut_SZ_<hydro_name>_<freq>_<scheme>_<level_name>.nc

            levela_name_lut = (FOLDER_LUT+"lut_SZ_"+hydrom_type+'_'+
                    str(frequency).replace('.','_')+'_'+scheme+"_LevelA"+".nc")

            levelb_name_lut = (FOLDER_LUT+"lut_SZ_"+hydrom_type+'_'+
                    str(frequency).replace('.','_')+'_'+scheme+"_LevelB"+".nc")
            
            if (FORCE_REGENERATION_SCATTER_TABLES
                or not os.path.exists(levelb_name_lut)):
                msg = '''
                Generating scatter table for 1 moment scheme,
                hydrometeor = {:s}
                freq = {:s}
                '''.format(hydrom_type, str(frequency))
                print(msg)

                sz_lut(hydrom_type, frequency, levela_name_lut, levelb_name_lut)
